/*
8.5.1 실행 가능한 코드 
전역코드 : window 객체 아래 정의된 함수
함수
eval코드 : eval함수
자바스크립트 엔진이 실행 가능한 코드의 유형을 분류하는 이유는 실행 문맥을 초기화하는 환경과 과정이 다르기 때문
특히 eval코드는 앞으로 섦여할 렉시컬 환경이 아니라 별도 동적 환경에서 실행됨

8.5.2 실행 문맥의 구성
실행 문맥이 실행 가능한 코드가 실제 실행되고 관리되는 영역으로 실행에 필요한
모든 정보를 컴포넌트 여러개가 나누어 관리하도록 만들어져있다. 
1. 렉시컬 환경 컴포넌트
2. 변수환경 컴포넌트
3. 디스바인딩 컴포넌트 
ExcutionContext = {
    LexicalEnvironment :{}, ->렉시컬 환경
    VariableEnvironment:{}, -> 변수환경
    ThisBinding :null ->디스바인딩
}

8.5.3 렉시컬 환경 컴포넌트의 구성 
렉시컬 환경 컴포넌트는 자바스크립트 엔진이 자바 스크립트 코드를 실행하기 위해 자원을 모아둔 곳으로
구체적으로는 함수 또는 블록의 유효범위 안에 있는 식별자와 그 결과값이 저장되는 곳이다. 
1. 환경 레코드
EnvrionmentRecord :{}
유효범위 안에 포함된 식별자 기록, 실행. 변수 객체와 유사 
유효범위 안의 식별자와 결과값을 반인드해서 환경레코드에 기록
2. 외부 렉시컬 환경 참조 
OuterLexicalEnvironment Reference:{}
자스가 중첩함수가 가능한데, 유효범위 너머의 유효범위도 검색할 수 있어야한다. 
외부 렉시컬 환경참조는 함수를 둘러 싸고 있는 코드가 속한 렉시컬 환경 컴포넌트읯 ㅏㅁ조가 저장됨

8.5.4 환경 레코드의 구성
환경레코드는 렉시컬 환경 안의 식별자와 그 식별자가 가리키는 값의 묶음이 실제로 저장되는 영역
1. 선언적 환경 레코드
실제로 함수와 변수, catch문의 식별자와 실행결과가 저장됨
식별자와 그 실행결과를 키와 값의 쌍으로 관리
2. 객체 환경 레코드
실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 씀
with문의 렉시컬 환경이나 전역객체처럼 별도의 객체에 저장된 데이터는 그 객체가 가진
키와 값의 쌍을 복사해오는게 아니고, 객체 전체의 참조를 가져와 객체 환경 레코드의
bindObject라는 프로퍼티에 바인드함

8.5.5 전역 환경과 전역 객체의 생성
자스의 인터프리터는 시작하자마자 렉시컬 환경 타입의 전역 환경을 생성
새로운 웹 페이지를 읽어 들인 후 전역환경을 생성하고 전역 객체를 생성한 다음
전역 환경의 객체 환경 레코드에 전역 객체의 참조를 대입.
취상의 레벨의 this는 전역 객체를 가리킨다. 
//전역환경
//전역 실행 문맥
웹 브라우저 자바스크립트 실행 환경에서는 window가 전역객체이므로 
bindObject 프로퍼티에는 전역객체 window 참조가 할당됨
그리고 외부에 다른 렉시컬 환경이 없으므로 null이 할당
디스바인딩 컴포넌트에 winodw의 참조가 할당되어 this가 window를 가리키면 
전역 실행 문맥의 프로퍼티를 디스 바인딩 컴포넌트 안에서 검색하게 된다. 

8.5.6 프로그램의 평가와 전역변수
프로그램을 다 읽어들인 후에 프로그램을 평가하고 최상위 레벨에 var문으로 작성한 전역 변수는 
전역 환경의 환경레코드의 프로퍼티로 추가된다. 

자바스크립트 엔진은 전역 코드를 평가할 때 최상의 레벨에 var 문으로 작성한 전역변수를 전역환경의 환경 레코드에 프로퍼티로 기록한다.
프로퍼티 이름은 식별자 이름이고 값은 undefined
최상위 레벨에 선언된 변수와 함수는 프로그램을 평가할때 객체 환경 레코드에 기록한다. 
전역변수의 실체는 전역 객체의 프로퍼티 또는 전역 객체의 실행 문맥에 들어있는 환경 레코드의 프로퍼티 
(끌어올림 현상의 실체), configurable로 참조가능

8.5.7 프로그램 실행과 실행 문맥
실행문맥은 실행가능한 코드(전역코드, eval 코드, 함수코드)별로 생성됨
스택구조로 관리되고 실행 문맥은 프로그램 실행 중 스택에 push되어 실행됨. 
전역코드가 가장먼저 실행되고 스택 맨 아래에 전역코드를 실행하기 위한 실행 문맥이 있음. 
중첩함수의 실행 문맥이 외부함수의 실행문맥안에서 중첩되지 않음!(다르 실행문맥을 만들어서 스택에 push)
재귀호출은 호출한 함수와 같지만 전혀 다르 함수로 스택에 푸시됨
실행문맥 스택을 호출 스택이라고함

8.5.8 자바스크립트는 싱글 스레드
싱글스레드와 멀티스레드 방식
스레드 : 프로그램의 처리 흐름
싱글 스레드 방식은 프로그램 한 개의 처리 흐름으로 프로그램을 순차적으로 실행하는 방식
멀티스레드 방식은 프로그램 여러개의 처리 흐름으로 동시에 작업을 여러 개 병렬로 실행하는 방식 

자바스크립트는 싱글스레드로 처리, 실행 문맥을 위에서부터 아래로 차례차례 실행
비동기도 똑같은 방식으로 실행 비동기처리는 이벤트큐에 대기행렬을 만들어서 관리함
멀티스레드 처리는 Web Workers를 사용하면 가능하다고 함

8.5.9 환경 레코드와 지역변수
함수를 호출하면 현재 실행중인 작업흐름을 일시적으로 멈추고 실행문맥 영역을 생성함 -> 그 실행 문맥으로 이동 
-> 그 함수의 실행문맥이 호출스택에 push -> 실행문맥 안에 렉시컬 환경 컴포넌트생성 -> this 바인딩 -> 코드가 순서대로 실행

여기서 생성된 렉시컬 환경 컴포넌트는 환경 레코드를 가지고있고, 여기에 함수 안팎의 환경을 기록함
환경 레코드는 사용자가 읽거나 쓸 수 없으며 다음과 같은 정보를 기록하는 용도
- 함수의 인자, 중첩된 함수의 참조, var로 선언한 지역변수, argument
대응하는 인수가 없다면 undefined로 설정

8.5.10 this 값
함수가 호출되어 실행되는 시점에서 this가 결정된다. 
1 최상위 레벨 코드의 this -> window
2 이벤트 처리기 안에 있는this -> 이벤트가 발생한 요소
3 생성자 함수 안에 있는 this -> 생성자로 생성한 객체
4 생성자의 prototype 메서드 안에 있는 this -> 그 생성자로 생성한 객체
5 직접 호출한 함수 안의 this -> 함수 f를 호출할때 아무것도 붙이지않으면 전역 객체를 가리켜서 window
6 apply와 call 메서드로 호출한 함수안에 있는 this ->ㅇ 객체가 실행되는 실행 문맥의 디스 바인딩 컴포넌트가 가리키는 객체를 명시적으로 설정 가능

*/
var Tom = {
  name: "Tom",
  sayHello: function () {
    console.log("Hello!" + this.name);
  },
};

Tom.sayHello();
var huck = { name: "Huck" };
huck.sayHello = Tom.sayHello;
huck.sayHello();

function f() {
  console.log(this);
}

/*
8.5.11 식별자 결정 : 유효범위 체인
식별자 결정 : x가 어디에서 선언된 변수인지 결정하는 작업 - 좀 더 안쪽 코드에 선언된 변수를 사용한다가 규칙

일반적으로 함수의 인수와 지역변수를 속박변ㄴ수라고 하고, 그 외를 자유변수라고 함
속박변수로만 포함된 함수를 닫힌 함수, 자유 변수를 가지고 있는 함수를 열린함수라고 함

유효범위 안에 없는 식별자를 찾을 떄 바깥쪽 범위로 호출자의 렉시컬 환경에 속한 외부 렉시컬 환경의 참조를 따라가는 방식을 취함
논리적연결고리 기준에서는 스코프체인이라고 하나 이 용어가 사라져 외부 렉시컬 환경 체인이라고 함 다만 공식 단어는 아님
결론 : 유효범위 체인

*/

var a = "A"; //자유변수
function f() {
  var b = "B"; // 자유변수
  function g() {
    var c = "C"; // 속박변수
    console.log(a + b + c);
  }
  g();
}
f(); //ABC

/* 
8.5.12 가비지 컬렉션
프로그램에서 객체를 생성하면 메모리공간이 동적으로 확보됨
사용하지 않는 메모리영역은 가비지 컬렉터가 자동으로 헤제하고 이를 가비지 컬렉션이라고 한다. 
가비지컬렉션이 동작하는 방식이 IE6나 파이어폭스에서는 DOM 객체의 가비지 컬렉션에 참조카운터 방식을 사용함
참조 카운터 방식 : 참조하는 객체 수를 세어 참조하는 객체 개수가 0이 되면 메모리에서 해제
순환 참조가 발생하면 메모리 누수가 발생한다는 단점
순환 참조 :  var p = {x:0,y:0}, q = {x:1,y:1};
p.next = q; q.next = p;
최근에는 마크 앤 스윕 알고리즘을 쓴다 
전역객체가 참조할 수 없는 객체를 검색하고 해당하는 객체가 있으면 필요없다고 판단해 메모리에서 해제하는 방식 
순환참조데 의한 메모리 누수 발생  X
*/
